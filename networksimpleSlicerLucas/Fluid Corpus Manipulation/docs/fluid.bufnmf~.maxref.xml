<?xml version='1.0' encoding='utf-8' standalone='yes'?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>
<!--
Part of the Fluid Corpus Manipulation Project (http://www.flucoma.org/)
Copyright 2017-2019 University of Huddersfield.
Licensed under the BSD-3 License.
See license.md file in the project root for full license information.
This project has received funding from the European Research Council (ERC)
under the European Unionâ€™s Horizon 2020 research and innovation programme
(grant agreement No 725899).
-->
<!-- DO NOT EDIT THIS FILE ... YOU WILL LOSE YOUR WORK -->
<c74object name='fluid.bufnmf~' category='FluidCorpusManuipulation'>
	<digest>Buffer-Based Non-Negative Matrix Factorisation on Spectral Frames</digest>
	<description><div class="document">
<p>Decomposes the spectrum of a sound into a number of components using Non-Negative Matrix Factorisation (NMF)</p>
</div>
</description>
  <discussion>
      <h4><openfilelink filename="Fluid Corpus Manipulation Toolkit.maxpat">Open the Overview Patch</openfilelink></h4>
    <div class="document">
<p>NMF has been a popular technique in signal processing research for things like source separation and transcription (see Smaragdis and Brown, Non-Negative Matrix Factorization for Polyphonic Music Transcription.), although its creative potential is so far relatively  unexplored.</p>
<p>The algorithm takes a buffer in and divides it into a number of components, determined by the components argument. It works iteratively, by trying to find a combination of spectral templates ('bases') and envelopes ('activations') that yield the original magnitude spectrogram when added together. By and large, there is no unique answer to this question (i.e. there are different ways of accounting for an evolving spectrum in terms of some set of templates and envelopes). In its basic form, NMF is a form of unsupervised learning: it starts with some random data and then converges towards something that minimizes the distance between its generated data and the original:it tends to converge very quickly at first and then level out. Fewer iterations mean less processing, but also less predictable results.</p>
<dl class="docutils">
<dt>The object can return either or all of the following:</dt>
<dd><ul class="first last simple">
<li>a spectral contour of each component in the form of a magnitude spectrogram (called a basis in NMF lingo);</li>
<li>an amplitude envelope of each component in the form of gains for each consecutive frame of the underlying spectrogram (called an activation in NMF lingo);</li>
<li>an audio reconstruction of each components in the time domain.</li>
</ul>
</dd>
</dl>
<p>The bases and activations can be used to make a kind of vocoder based on what NMF has 'learned' from the original data. Alternatively, taking the matrix product of a basis and an activation will yield a synthetic magnitude spectrogram of a component (which could be reconsructed, given some phase informaiton from somewhere).</p>
<p>Some additional options and flexibility can be found through combinations of the basesMode and actMode arguments. If these flags are set to 1, the object expects to be supplied with pre-formed spectra (or envelopes) that will be used as seeds for the decomposition, providing more guided results. When set to 2, the supplied buffers won't be updated, so become templates to match against instead. Note that having both bases and activations set to 2 doesn't make sense, so the object will complain.</p>
<dl class="docutils">
<dt>If supplying pre-formed data, it's up to the user to make sure that the supplied buffers are the right size:</dt>
<dd><ul class="first last simple">
<li>bases must be <cite>(fft size / 2) + 1</cite> frames and <cite>(components * input channels)</cite> channels</li>
<li>activations  must be <cite>(input frames / hopSize) + 1</cite> frames and <cite>(components * input channels)</cite> channels</li>
</ul>
</dd>
</dl>
<p>In this implementation, the components are reconstructed by masking the original spectrum, such that they will sum to yield the original sound.</p>
<p>The whole process can be related to a channel vocoder where, instead of fixed bandpass filters, we get more complex filter shapes that are learned from the data, and the activations correspond to channel envelopes.</p>
</div>


		fluid.bufnmf~ is part of the Fluid Decomposition Toolkit of the FluCoMa project. For more explanations, learning material, and discussions on its musicianly uses, visit <a href="http://www.flucoma.org/">flucoma.org</a>.

  </discussion>
	<!--METADATA-->
	<metadatalist>
		<metadata name='author'>FluCoMa</metadata>
		<metadata name='tag'>Fluid Decomposition</metadata>
		<metadata name='tag'>corpus</metadata>
	</metadatalist>
	<!--ARGUMENTS-->
	<objarglist><!-- <objarg name='function' optional='1' type='number'>
			<digest>Initial easing function to use</digest>
			<description>Initial easing function to use. </description>
		</objarg>-->
	</objarglist>
	<!--MESSAGES-->
  <methodlist><method name="bang">
     <arglist />
     <digest>
       Trigger processing
     </digest>
     <description>
       A bang will commence processing on object given its current settings, unless it is already busy. In that case, the behaviour depends on the value of the <m>queue</m> attribute.
     </description>
   </method>
   <method name="cancel">
     <arglist />
     <digest>
       Cancel non-blocking processing
     </digest>
     <description>
       When processing in non-blocking mode, this will cancel the job underway, without updating destination buffers.
     </description>
   </method><method name="reset">
      <arglist />
      <digest>
        Return the object to its original state
      </digest>
      <description>
        Calling <m>reset</m> will change parameter values back to those the object was <i>created</i> with, i.e. any attribute values set in the box will be retained
      </description>
    </method></methodlist>
	<!--ATTRIBUTES-->
	<attributelist><attribute name='activations' get='1' set='1' type='symbol' size='1'>
        <digest>
          Activations Buffer
        </digest>
        <description>
          <div class="document">
<p>The index of the buffer where the different activations will be written to and/or read from: the behaviour is set in the following argument. If <cite>nil</cite> is provided, no activation will be returned.</p>
</div>

          
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='None' /></attributelist></attribute><attribute name='actmode' get='1' set='1' type='int' size='1'>
        <digest>
          Activations Buffer Update Mode
        </digest>
        <description>
          <div class="document">
<p>This flag decides of how the activation buffer passed as the previous argument is treated.</p>
</div>

          
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='0' /><attribute name="enumvals" get="1" set="1" type="atom" size='3'>
            <enumlist><enum name='None'>
                <description>
                  <div class="document">
<p>The activations are seeded randomly, and the resulting ones will be written after the process in the passed buffer. The buffer is resized to <cite>components * numChannelsProcessed</cite> channels and <cite>(sourceDuration / hopsize + 1)</cite> lenght.</p>
</div>

                </description>
              </enum><enum name='Seed'>
                <description>
                  <div class="document">
<p>The passed buffer is considered as seed for the activations. Its dimensions should match the values above. The resulting activations will replace the seed ones.</p>
</div>

                </description>
              </enum><enum name='Fixed'>
                <description>
                  <div class="document">
<p>The passed buffer is considered as a template for the activations, and will therefore not change. Its dimensions should match the values above.</p>
</div>

                </description>
              </enum></enumlist>
          </attribute></attributelist></attribute><attribute name='bases' get='1' set='1' type='symbol' size='1'>
        <digest>
          Bases Buffer
        </digest>
        <description>
          <div class="document">
<p>The index of the buffer where the different bases will be written to and/or read from: the behaviour is set in the following argument. If <cite>nil</cite> is provided, no bases will be returned.</p>
</div>

          
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='None' /></attributelist></attribute><attribute name='basesmode' get='1' set='1' type='int' size='1'>
        <digest>
          Bases Buffer Update Mode
        </digest>
        <description>
          <div class="document">
<p>This flag decides of how the basis buffer passed as the previous argument is treated.</p>
</div>

          
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='0' /><attribute name="enumvals" get="1" set="1" type="atom" size='3'>
            <enumlist><enum name='None'>
                <description>
                  <div class="document">
<p>The bases are seeded randomly, and the resulting ones will be written after the process in the passed buffer. The buffer is resized to <cite>components * numChannelsProcessed</cite> channels and <cite>(fftSize / 2 + 1)</cite> lenght.</p>
</div>

                </description>
              </enum><enum name='Seed'>
                <description>
                  <div class="document">
<p>The passed buffer is considered as seed for the bases. Its dimensions should match the values above. The resulting bases will replace the seed ones.</p>
</div>

                </description>
              </enum><enum name='Fixed'>
                <description>
                  <div class="document">
<p>The passed buffer is considered as a template for the bases, and will therefore not change. Its bases should match the values above.</p>
</div>

                </description>
              </enum></enumlist>
          </attribute></attributelist></attribute><attribute name='blocking' get='1' set='1' type='int' size='1'>
        <digest>
          Blocking Mode
        </digest>
        <description>
          <div class="document">
<p>Set the threading mode for the object</p>
</div>

          
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='1' /><attribute name="enumvals" get="1" set="1" type="atom" size='3'>
            <enumlist><enum name='Non-Blocking'>
                <description>
                  <div class="document">
<p>Processing runs in a worker thread</p>
</div>

                </description>
              </enum><enum name='Blocking (Low Priority)'>
                <description>
                  <div class="document">
<p>Processing runs in the main application thread</p>
</div>

                </description>
              </enum><enum name='Blocking (High Priority)'>
                <description>
                  <div class="document">
<p>(Max only) Processing runs in the scheduler thread</p>
</div>

                </description>
              </enum></enumlist>
          </attribute></attributelist></attribute><attribute name='components' get='1' set='1' type='int' size='1'>
        <digest>
          Number of Components
        </digest>
        <description>
          <div class="document">
<p>The number of elements the NMF algorithm will try to divide the spectrogram of the source in.</p>
</div>

          <h5>Constraints</h5><ul><li>Minimum: 1</li></ul>
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='1' /></attributelist></attribute><attribute name='fftsettings' get='1' set='1' type='int' size='3'>
        <digest>
          FFT Settings
        </digest>
        <description>
          <div class="document">
<p>FFT settings consist of three numbers representing the window size, hop size and FFT size in samples:</p>
<p>The hop size and fft size can both be set to -1 (and are by default), with slightly different meanings:</p>
<ul class="simple">
<li>For the hop size, -1 = <tt class="docutils literal">windowSize/2</tt></li>
<li>For the FFT size, -1 = <tt class="docutils literal">windowSize</tt> snapped to the nearest equal / greater power of 2 (e.g. <tt class="docutils literal">windowSize 1024</tt> =&gt; <tt class="docutils literal">fftSize 1024</tt>, but <tt class="docutils literal">windowsSize 1000</tt> also =&gt; <tt class="docutils literal">fftSize 1024</tt>)</li>
</ul>
</div>

          <h5>Constraints</h5><ul><li> FFTSize, if != -1, will set to the next greatest power of two &gt; 4</li></ul>
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='3' value='[[&#39;winSize&#39;, 1024], [&#39;hopSize&#39;, -1], [&#39;fftSize&#39;, -1]]' /></attributelist></attribute><attribute name='iterations' get='1' set='1' type='int' size='1'>
        <digest>
          Number of Iterations
        </digest>
        <description>
          <div class="document">
<p>The NMF process is iterative, trying to converge to the smallest error in its factorisation. The number of iterations will decide how many times it tries to adjust its estimates. Higher numbers here will be more CPU expensive, lower numbers will be more unpredictable in quality.</p>
</div>

          <h5>Constraints</h5><ul><li>Minimum: 1</li></ul>
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='100' /></attributelist></attribute><attribute name='numchans' get='1' set='1' type='int' size='1'>
        <digest>
          Number Channels
        </digest>
        <description>
          <div class="document">
<p>For multichannel srcBuf, how many channel should be processed.</p>
</div>

          
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='-1' /></attributelist></attribute><attribute name='numframes' get='1' set='1' type='int' size='1'>
        <digest>
          Number of Frames
        </digest>
        <description>
          <div class="document">
<p>How many frames should be processed.</p>
</div>

          
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='-1' /></attributelist></attribute><attribute name='queue' get='1' set='1' type='int' size='1'>
        <digest>
          Non-Blocking Queue Flag
        </digest>
        <description>
          <div class="document">
<p>In non-blocking mode enable jobs to be queued up if successive bangs are sent whilst the object is busy. With the queue disabled, successive bangs will produce a warning. When enabled, the object will processing successively, against the state of its parameters when each bang was sent</p>
</div>

          
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='0' /></attributelist></attribute><attribute name='resynth' get='1' set='1' type='symbol' size='1'>
        <digest>
          Resynthesis Buffer
        </digest>
        <description>
          <div class="document">
<p>The index of the buffer where the different reconstructed components will be reconstructed. The buffer will be resized to <cite>components * numChannelsProcessed</cite> channels and <cite>sourceDuration</cite> lenght. If <cite>nil</cite> is provided, the reconstruction will not happen.</p>
</div>

          
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='None' /></attributelist></attribute><attribute name='source' get='1' set='1' type='symbol' size='1'>
        <digest>
          Source Buffer
        </digest>
        <description>
          <div class="document">
<p>The index of the buffer to use as the source material to be decomposed through the NMF process. The different channels of multichannel buffers will be processing sequentially.</p>
</div>

          
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='None' /></attributelist></attribute><attribute name='startchan' get='1' set='1' type='int' size='1'>
        <digest>
          Start Channel
        </digest>
        <description>
          <div class="document">
<p>For multichannel srcBuf, which channel should be processed first.</p>
</div>

          <h5>Constraints</h5><ul><li>Minimum: 0</li></ul>
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='0' /></attributelist></attribute><attribute name='startframe' get='1' set='1' type='int' size='1'>
        <digest>
          Source Offset
        </digest>
        <description>
          <div class="document">
<p>Where in the srcBuf should the NMF process start, in sample.</p>
</div>

          <h5>Constraints</h5><ul><li>Minimum: 0</li></ul>
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='0' /></attributelist></attribute><attribute name='warnings' get='1' set='1' type='int' size='1'>
        <digest>
          Warnings
        </digest>
        <description>
          <div class="document">
<p>Enable warnings to be issued whenever a parameter value is constrained (e.g. clipped)</p>
</div>

          <h5>Constraints</h5><ul><li>Minimum: 0</li><li>Maximum: 1</li></ul>
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='0' /></attributelist></attribute></attributelist>
	<!--RELATED-->
	<seealsolist>
    
    <seealso name='fluid.nmfmatch~' />
    <seealso name='fluid.nmffilter~' />
	</seealsolist>
</c74object>