<?xml version='1.0' encoding='utf-8' standalone='yes'?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>
<!--
Part of the Fluid Corpus Manipulation Project (http://www.flucoma.org/)
Copyright 2017-2019 University of Huddersfield.
Licensed under the BSD-3 License.
See license.md file in the project root for full license information.
This project has received funding from the European Research Council (ERC)
under the European Unionâ€™s Horizon 2020 research and innovation programme
(grant agreement No 725899).
-->
<!-- DO NOT EDIT THIS FILE ... YOU WILL LOSE YOUR WORK -->
<c74object name='fluid.hpss~' category='FluidCorpusManuipulation'>
	<digest>Harmonic-Percussive Source Separation Using Median Filtering</digest>
	<description><div class="document">
<p>Harmonic-Percussive Source Separation (HPSS) on the an audio input.</p>
</div>
</description>
  <discussion>
      <h4><openfilelink filename="Fluid Corpus Manipulation Toolkit.maxpat">Open the Overview Patch</openfilelink></h4>
    <div class="document">
<p>HPSS works by using median filters on the spectral magnitudes of a sound. It hinges on a simple modelling assumption that tonal components will tend to yield concentrations of energy across time, spread out in frequency, and percussive components will manifest as concentrations of energy across frequency, spread out in time. By using median filters across time and frequency respectively, we get initial esitmates of the tonal-ness / transient-ness of a point in time and frequency. These are then combined into 'masks' that are applied to the orginal spectral data in order to produce a separation.
The maskingMode parameter provides different approaches to combinging estimates and producing masks. Some settings (especially in modes 1 &amp; 2) will provide better separation but with more artefacts. These can, in principle, be ameliorated by applying smoothing filters to the masks before transforming back to the time-domain (not yet implemented).</p>
</div>


		fluid.hpss~ is part of the Fluid Decomposition Toolkit of the FluCoMa project. For more explanations, learning material, and discussions on its musicianly uses, visit <a href="http://www.flucoma.org/">flucoma.org</a>.

  </discussion>
	<!--METADATA-->
	<metadatalist>
		<metadata name='author'>FluCoMa</metadata>
		<metadata name='tag'>Fluid Decomposition</metadata>
		<metadata name='tag'>corpus</metadata>
	</metadatalist>
	<!--ARGUMENTS-->
	<objarglist><objarg name='maxfftsize' optional='1' type='number'>
        <digest>
          Maxiumm FFT Size
        </digest>
        <description>
          <div class="document">
<p>How large can the FFT be, by allocating memory at instantiation time. This cannot be modulated.</p>
</div>

          <h5>Constraints</h5><ul><li>Minimum: 4</li><li>Snaps to powers of two</li></ul>
        </description><attributelist>
          <attribute name="default" get="1" set="1" type="int" size='1' value='16384' />
        </attributelist></objarg><objarg name='maxharmfiltersize' optional='1' type='number'>
        <digest>
          Maximum Harmonic Filter Size
        </digest>
        <description>
          <div class="document">
<p>How large can the harmonic filter be modulated to (harmFilterSize), by allocating memory at instantiation time. This cannot be modulated.</p>
</div>

          <h5>Constraints</h5><ul><li>Minimum: 3</li><li>Snaps to odd numbers</li></ul>
        </description><attributelist>
          <attribute name="default" get="1" set="1" type="int" size='1' value='101' />
        </attributelist></objarg><objarg name='maxpercfiltersize' optional='1' type='number'>
        <digest>
          Maximum Percussive Filter Size
        </digest>
        <description>
          <div class="document">
<p>How large can the percussive filter be modulated to (percFilterSize), by allocating memory at instantiation time. This cannot be modulated.</p>
</div>

          <h5>Constraints</h5><ul><li>Minimum: 3</li><li>Snaps to odd numbers</li></ul>
        </description><attributelist>
          <attribute name="default" get="1" set="1" type="int" size='1' value='101' />
        </attributelist></objarg><!-- <objarg name='function' optional='1' type='number'>
			<digest>Initial easing function to use</digest>
			<description>Initial easing function to use. </description>
		</objarg>-->
	</objarglist>
	<!--MESSAGES-->
  <methodlist><method name="reset">
      <arglist />
      <digest>
        Return the object to its original state
      </digest>
      <description>
        Calling <m>reset</m> will change parameter values back to those the object was <i>created</i> with, i.e. any attribute values set in the box will be retained
      </description>
    </method></methodlist>
	<!--ATTRIBUTES-->
	<attributelist><attribute name='fftsettings' get='1' set='1' type='int' size='3'>
        <digest>
          FFT Settings
        </digest>
        <description>
          <div class="document">
<p>FFT settings consist of three numbers representing the window size, hop size and FFT size in samples:</p>
<p>The hop size and fft size can both be set to -1 (and are by default), with slightly different meanings:</p>
<ul class="simple">
<li>For the hop size, -1 = <tt class="docutils literal">windowSize/2</tt></li>
<li>For the FFT size, -1 = <tt class="docutils literal">windowSize</tt> snapped to the nearest equal / greater power of 2 (e.g. <tt class="docutils literal">windowSize 1024</tt> =&gt; <tt class="docutils literal">fftSize 1024</tt>, but <tt class="docutils literal">windowsSize 1000</tt> also =&gt; <tt class="docutils literal">fftSize 1024</tt>)</li>
</ul>
</div>

          <h5>Constraints</h5><ul><li> FFTSize, if != -1, will set to the next greatest power of two &gt; 4</li><li>The maximum manual FFT size is limited to the value of the <at>maxfftsize</at> initialization argument</li><li>if FFT size != -1, then window size is clipped at FFT size</li></ul>
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='3' value='[[&#39;winSize&#39;, 1024], [&#39;hopSize&#39;, -1], [&#39;fftSize&#39;, -1]]' /></attributelist></attribute><attribute name='harmfiltersize' get='1' set='1' type='int' size='1'>
        <digest>
          Harmonic Filter Size
        </digest>
        <description>
          <div class="document">
<p>The size, in spectral frames, of the median filter for the harmonic component. Must be an odd number, &gt;= 3.</p>
</div>

          <h5>Constraints</h5><ul><li>Minimum: 3</li><li>Maximum: <at>maxharmfiltersize</at></li><li>Snaps to odd numbers</li></ul>
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='17' /></attributelist></attribute><attribute name='harmthresh' get='1' set='1' type='float64' size='4'>
        <digest>
          Harmonic Filter Thresholds
        </digest>
        <description>
          <div class="document">
<p>When maskingmode is 1 or 2, set the threshold curve for classifying an FFT bin as harmonic. Takes a list of two frequency-amplitude pairs as coordinates: between these coordinates the threshold is linearly interpolated, and is kept constant between DC and coordinate 1, and coordinate 2 and Nyquist.</p>
</div>

          <h5>Constraints</h5><ul><li>Two amplitude + frequency pairs. Amplitudes are unbounded, frequencies in range 0-1</li></ul>
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='4' value='{&#39;value&#39;: [[0.0, 1.0], [1.0, 1.0]]}' /></attributelist></attribute><attribute name='maskingmode' get='1' set='1' type='int' size='1'>
        <digest>
          Masking Mode
        </digest>
        <description>
          <div class="document">
<p>The way the masking is applied to the original spectrogram. (0,1,2)</p>
</div>

          
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='0' /><attribute name="enumvals" get="1" set="1" type="atom" size='3'>
            <enumlist><enum name='Classic'>
                <description>
                  <div class="document">
<p>The traditional soft mask used in Fitzgerald's original method of 'Wiener-inspired' filtering. Complimentary, soft masks are made for the harmonic and percussive parts by allocating some fraction of a point in time-frequency to each. This provides the fewest artefacts, but the weakest separation. The two resulting buffers will sum to exactly the original material.</p>
</div>

                </description>
              </enum><enum name='Coupled'>
                <description>
                  <div class="document">
<p>Relative mode - Better separation, with more artefacts. The harmonic mask is constructed using a binary decision, based on whether a threshold is exceeded at a given time-frequency point (these are set using harmThreshFreq1, harmThreshAmp1, harmThreshFreq2, harmThreshAmp2, see below). The percussive mask is then formed as the inverse of the harmonic one, meaning that as above, the two components will sum to the original sound.</p>
</div>

                </description>
              </enum><enum name='Advanced'>
                <description>
                  <div class="document">
<p>Inter-dependent mode - Thresholds can be varied independently, but are coupled in effect. Binary masks are made for each of the harmonic and percussive components, and the masks are converted to soft at the end so that everything null sums even if the params are independent, that is what makes it harder to control. These aren't guranteed to cover the whole sound; in this case the 'leftovers' will placed into a third buffer.</p>
</div>

                </description>
              </enum></enumlist>
          </attribute></attributelist></attribute><attribute name='percfiltersize' get='1' set='1' type='int' size='1'>
        <digest>
          Percussive Filter Size
        </digest>
        <description>
          <div class="document">
<p>The size, in spectral bins, of the median filter for the percussive component. Must be an odd number, &gt;=3</p>
</div>

          <h5>Constraints</h5><ul><li>Minimum: 3</li><li>Maximum: <at>maxpercfiltersize</at></li><li>Snaps to odd numbers</li></ul>
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='31' /></attributelist></attribute><attribute name='percthresh' get='1' set='1' type='float64' size='4'>
        <digest>
          Percussive Filter Thresholds
        </digest>
        <description>
          <div class="document">
<p>In maskingmode 2, an independant pair of frequency-amplitude pairs defining the threshold for the percussive part. Its format is the same as above.</p>
</div>

          <h5>Constraints</h5><ul><li>Two amplitude + frequency pairs. Amplitudes are unbounded, frequencies in range 0-1</li></ul>
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='4' value='{&#39;value&#39;: [[0.0, 1.0], [1.0, 1.0]]}' /></attributelist></attribute><attribute name='warnings' get='1' set='1' type='int' size='1'>
        <digest>
          Warnings
        </digest>
        <description>
          <div class="document">
<p>Enable warnings to be issued whenever a parameter value is constrained (e.g. clipped)</p>
</div>

          <h5>Constraints</h5><ul><li>Minimum: 0</li><li>Maximum: 1</li></ul>
        </description><attributelist><attribute name="default" get="1" set="1" type="int" size='1' value='0' /></attributelist></attribute></attributelist>
	<!--RELATED-->
	<seealsolist>
    
    <seealso name='fluid.bufhpss~' />
    <seealso name='fluid.sines~' />
    <seealso name='fluid.transients~' />
	</seealsolist>
</c74object>